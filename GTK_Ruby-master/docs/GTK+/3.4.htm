<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html><head>


  <title>Hello World in Ruby-GNOME2</title>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="Quanta Plus">
  <link rel="stylesheet" type="text/css" href="site-style.css">
</head><body>
<h1>3.4. Stepping Through Hello World</h1>

<p>Now that we know the theory behind this, let's clarify by walking through the example <i>helloworld.rb</i> program.</p>

<p>Here is the callback method that will be called when the button is "clicked". We ignore both the widget and the data in
this example, but it is not hard to do things with them. The next example will use the data argument to tell us which button
was pressed.</p>

<pre>def hello( widget )
   puts "Hello World."
end</pre>

<p>The next callback is a bit special. The "delete_event" occurs when the window manager sends this event to the
application. We have a choice here as to what to do about these events. We can ignore them, make some sort of response,
or simply quit the application.</p>

<p>The value you return in this callback lets GTK know what action to take. By returning true, we let it know that we don't 
want to have the "destroy" signal emitted, keeping your application running. By returning false, we ask that
"destroy" be emitted, which will in turn call our "destroy" signal handler.</p>

<pre>def delete_event( widget, event )
   puts "delete event occurred."
   return true
end</pre>

<p>Here is another callback method which causes the program to quit by calling Gtk.main_quit. This method tells GTK that it
is to exit from Gtk.main when control is returned to it.</p>

<pre>def destroy( widget )
   Gtk.main_quit
end</pre>

<p>Here is our Gtk.init again. As before, this initializes the toolkit.</p>
<pre>Gtk.init</pre>

<p>Create a new window. This is fairly straightforward, Memory is allocatted for a Gtk::Window. It sets up a new window, but
it is not displayed until we call Gtk::Widget#show near the end of our program.</p>

<pre>window = Gtk::Window.new(Gtk::Window::TOPLEVEL)</pre>

<p>This is another straightforward example. This sets the title, which is usually displayed in the titlebar, of our window.
If you do not specify a title, the name of the file is usually displayed.</p>
<pre>window.set_title( "helloworld.rb")</pre>

<p>Here are two examples of connecting a signal handler to an object, in this case, the window. Here, the "delete_event"
and "destroy" signals are caught. The first is emitted when we use the window manager to kill the window, or when we use
the Gtk::Widget#destroy call. The second is emitted when, in the "delete_event" handler, we return false.</p>

<pre>window.signal_connect( "delete_event" ) {
   delete_event( nil, nil )
}

window.signal_connect( "destroy" ) {
   destroy( nil )
}
</pre>

<p>This next method is used to set the attribute if a container object, the window in this case. This just sets the window
so it has a blank area along the inside of it 10 pixels wide where no widgets will go. There are similar methods which we
will look at in the section on Setting Widget Attributes.</p>

<pre>window.set_border_width( 10 ) </pre>

<p>This call creates a new button. It allocates space for a new Gtk::Widget in memory, initializes it, and makes the button.
It will have the label "Hello World" on it when displayed.</p>

<pre>button = Gtk::Button.new( "Hello World" )</pre>

<p>Here we take this button, and make it do something useful. We attach a signal handler to it so when it emits the 
"clicked" signal, our hello method is called. The widget is ignored, so we simply pass in nil to the hello callback
method. Obviously, the "clicked" signal is emitted when we click the button with our mouse pointer.</p>

<pre>button.signal_connect( "clicked" ) {
   hello( nil )
}</pre>

<p>We are also going to use this button to exit our program. This will illustrate how the "destroy" signal may come from
either the window manager, or our program. When the button is "clicked", same as above, it calls the first hello method,
and then this one in the order they are set up. You may have as many callback methods as you need, and will be executed
in the order you connected them. We also want the button to kill our application so we have to use the signal_connect_after, 
method:</p>

<pre>button.signal_connect_after ( "clicked" ) { destroy( nil ) }</pre>

<hr>
<table>
	<tbody><tr>
		<td align="left"><a href="3.3.htm">Prev</a></td>
		<td align="right"><a href="4.0.htm">Next</a></td>
	</tr>
</tbody></table>
</body></html>
