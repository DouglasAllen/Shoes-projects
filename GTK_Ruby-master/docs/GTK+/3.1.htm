<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html><head>


  <title>Hello World in Ruby-GNOME2</title>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="Quanta Plus">
  <link rel="stylesheet" type="text/css" href="site-style.css">
</head><body>
<h1>3.1. Hello World in Ruby-GNOME2</h1>

<p>Now for a program with a widget (a button). It's the classic hello world via Ruby-GNOME2. If you
don't feel like typing all of this out, you can find a very similar program in the ruby-gnome2 directory,
gtk/sample/misc/helloworld.rb. It will behave a bit different, but not much.</p>

<img src="images/hello.png" alt="Screenshot of helloworld.rb">

<pre># This initializes our library
require 'gtk2'

# This is a callback method. The data argument is ignored.
def hello( widget )
   puts "Hello World"
end

def delete_event( widget, event )

   # If you return false in the "delete_event" signal handler,
   # GTK will emit the "destroy" signal. Returning true means
   # that you don't want the window to be destroyed.
   # This is useful for popping up 'are you sure you want to quit?'
   # type dialogs.
   puts "delete event occurred."

   # Change true to false and the main window will be destroyed with
   # a "delete_event".
   return true
end

# Another callback
def destroy( widget )
   Gtk.main_quit
end

# This is called in <u>all</u> Ruby-GNOME2 applications.
Gtk.init

# Create a new window.
window = Gtk::Window.new( Gtk::Window::TOPLEVEL )

# Sets the window title.
window.set_title( "helloworld.rb" )

# Sets the border width of the window.
window.set_border_width( 10 )

# When the window is given the "delete_event" signal (this is given
# by the window manager, usually by the "close" option, or on the
# titlebar), we ask it to call the delete_event method
# as defined above. The data passed to the callback
# method is nil and is ignored in the callback method.
window.signal_connect( "delete_event" ) {
   delete_event( nil, nil )
}

# Here we connect the "destroy" event to a signal handler.
# This event occurs when we call Gtk::Widget#destroy on the window,
# or if we return false in the "delete_event" callback.
window.signal_connect( "destroy" ) {
   destroy( nil )
}

# Creates a new button with the label "Hello World".
button = Gtk::Button.new( "Hello World" )

# When the button receives the "clicked" signal, it will call the
# method hello, passing it nil as the argument. The hello
# method is defined above.
button.signal_connect( "clicked" ) {
   hello( nil ) 
}

# This packs the button into the window( a Gtk::Container )
window.add( button )

# The final step is to display the newly created widget
button.show

# And the window
window.show

# <u>All</u> Ruby-GNOME2 applications must have a Gtk.main. Control ends here
# and waits for an event to occur ( like a key press or mouse event ).
Gtk.main
</pre>

<hr>
<table>
	<tbody><tr>
		<td><a href="3.0.htm">Prev</a></td>
		<td align="right"><a href="3.2.htm">Next</a></td>
	</tr>
</tbody></table>
</body></html>
